        PROGRAM ILCcolider
C********************************************************************
C  V2L,V2R,V3L....ARE GAMMA MATRICES. THEY ARE ARRAYS AND THE LAST TWO 
C  INDICES ARE SPINOR INDICES. NOTE THEY ARE NOT DOUBLE PRECISION 
C  NUMBERS. BY THUS SETTING, WE CAN SAVE QUITE A LOT OF RAM WITHOUT 
C  LOSING PRECISION. IF IN YOUR COMPUTAION, YOU DONOT USE ANY GAMMA,
C  YOU CAN MARK THEM OUT.
C********************************************************************
      IMPLICIT REAL*8(A-H,o-Z)
      integer nf,ncall,i,j,ncomp,ni,ndis
      parameter (nf=2,ncomp=1,ni=2)
      double precision m(nf),pi(ni,4)
      integer  maxiter,neval,option,iter0
      integer  xunhuan,mm,nn
      double precision result,absacc,relacc,dis(1000,ncomp),
     &       err_dis(1000,ncomp),bin_min(ncomp),bin_max(ncomp),
     &       wid_bin(ncomp)
      DOUBLE PRECISION s,e,mu,alpha
      common/input/e,mu
      INTEGER xn
      common/s/s

c********initial condition **************************
      alpha = 1.d0/137.d0
      e=dsqrt(alpha*4.0d0*3.1415926d0)

      mu = 0.105
      open (unit=10,file='eemm.out')
      do xn=1,500

C**********************************************************
C  THE INPUT FOR MCPHASE
C**********************************************************

       m(1)=mu
       m(2)=mu

      s=(2*mu + xn*0.01)**2

      pi(1,1)=0.
      pi(1,2)=0.
      pi(1,3)=0.5*sqrt(s)
      pi(1,4)=0.5*sqrt(s)

      pi(2,1)=0.
      pi(2,2)=0.
      pi(2,3)=-0.5*sqrt(s)
      pi(2,4)= 0.5*sqrt(s)

      absacc=0.
      relacc=0.05
      ncall=5000
      maxiter=10

      bin_min(1)=0.
c      bin_min(2)=0.
      bin_max(1)=2000.
c      bin_max(2)=2000
      wid_bin(1)=10000.
c      wid_bin(2)=10000
      option =0 ! shut up  disfun
      iter0=50
      ndis=0   ! no distribution of integral


C****************************************************************
C THE FOLLOWING IS TO INTEGRATE THE PHASE SPACE, PATRON DISTRIBUTION.
C******************************************************************

       call mcphase(ni,pi,ndis,nf,m,result,absacc,relacc,ncall,
     &      maxiter,neval,option,ncomp,bin_min,
     &      bin_max,wid_bin,dis,err_dis,iter0)
c       pause
C****************************************************************

      print*,dsqrt(s),result*s,(4*3.1416*alpha**2/3.d0)
      write(10,*) dsqrt(s),result*s
      enddo

      close(10)

      end


**************************************************************************
c This subroutine defines the functions whose distribution will be obtained
c its for distribution of the final state
**************************************************************************
      subroutine disfun(ni,pi,nf,m,pf,ncomp,fun1)
      IMPLICIT NONE          !newly added
      integer ni,ncomp,i,nf
      double precision fun1(ncomp),pi(ni,4),m(nf),pf(nf,4)
          fun1(1)=1.
c        fun1(1)=pf(1,4)
c        fun1(2)=pf(2,4)
      end

**************************************************************************
* This subroutine defines the distribution of the initial state "wavedis".
* This subroutine defines the parton momentum.
**************************************************************************
      subroutine  patron(ni,ndis,var,pi,wavedis,pip)
      integer ni,ndis,i,j
      double precision var(ndis),wavedis,pi(ni,4),pip(ni,4)
      integer  Iset
      double precision Q,u1,ub1,u12,ub12,dcg1,mt,ctq5pdf,DCG2,cm2
         mt   = 178.
         Iset = 3 
         Call SetCtq5(Iset)   
         Q    = mt 
         u1  = Ctq5Pdf (   1,var(2), Q)                                
         ub1  = Ctq5Pdf ( -1, var(1)/var(2), Q) 
         u12  = Ctq5Pdf (   1, var(1)/var(2), Q)                                
         ub12  = Ctq5Pdf ( -1, var(2), Q)                       
         dcg1  = u1*ub1/var(2)+u12*ub12/var(2)  ! FOR C ALONG Z AXIS OR OPPOSITE TO Z AXIS

         wavedis = dcg1 
          do i=1,4
          pip(1,i)=var(2)*pi(1,i)
          enddo

          do j=1,4
          pip(2,j)=pi(2,j)*var(1)/var(2)
          enddo
c        print*,dcg1        
c        print*,pip(1,1),pip(1,2),pip(1,3),pip(1,4)
c        print*,pip(2,1),pip(2,2),pip(2,3),pip(2,4)
c        stop
        end
***************************************************************************
* This subroutine defines the upper and lower limit of the varable appeared 
* in the distribution function.
****************************************************************************  
     
      subroutine setlimit(ndis,var,upper,lower)
      IMPLICIT NONE          !newly added
      integer ndis,k
      double precision var(ndis), upper(ndis),lower(ndis)
      double precision mt,s
      common/s/s
    
         mt=178.

        lower(1)=(0.2+1.)**2/s
        upper(1)=0.1
        lower(2)=var(1)
        upper(2)=0.5

c       do k=1,ndis
c         upper(k)=1.
c       enddo

c         lower(1)=0.5
c         lower(2)=var(1)
      end


****************************************************************************
* The Jacobi coefficient will be got in this subroutine.
****************************************************************************
      subroutine jacobi(ndis,var,jacob)

      integer ndis, k
      double precision var(ndis), upper(ndis), lower(ndis),jacob,range

      call setlimit(ndis,var,upper,lower)

      jacob=1.
      do k=1,ndis
      range=upper(k)-lower(k)
      jacob=jacob*range
      enddo

      end

****************************************************************************
* The transformed distribution will be get in this subrountine. The varables 
* of the distribution varies between 0 and 1.
****************************************************************************
      subroutine  inidis(ni,ndis,y1,pi,pip,finidis)
      IMPLICIT NONE          !newly added
      integer ni,ndis,dim,i
      double precision y1(ndis),pi(ni,4),pip(ni,4),finidis,var(ndis),
     &   jacob,upper(ndis),lower(ndis),wavedis,check
      do dim=1,ndis
         var(dim)=0.
      enddo

       do dim=1,ndis
           call setlimit(ndis,var,upper,lower)
           var(dim)=lower(dim)+(upper(dim)-lower(dim))*y1(dim)
      enddo

        call patron(ni,ndis,var,pi,wavedis,pip)
        call jacobi(ndis,var,jacob)
        finidis= jacob*wavedis
c      print*,'finidis,jacob,wavedis'
c      print*,finidis,jacob,wavedis
      end
